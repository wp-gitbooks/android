# 线索-记忆点



<font color="red">类加载---过程：加验准解初使卸：教练准假初始歇</font>

<font color="red">类初始化：分类、when、过程(顺序)</font>

<font color="red">对象创建：分类、how（过程或顺序）</font>





# 概述

1、什么是类加载？什么时候进行类加载？

2、什么是类初始化？什么时候进行类初始化？

3、什么时候会为变量分配内存？

4、什么时候会为变量赋默认初值？什么时候会为变量赋程序设定的初值？

5、类加载器是什么？

6、如何编写一个自定义的类加载器？



# 类加载的过程

## 类的生命周期

```
加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载
       |<------- 连接 ------->|
|<------------- 类加载 ---------------->|
```

![类的生命周期](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144307)



## 加载

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144211)

### 加载的 3 个阶段

- 通过类的全限定名获取二进制字节流（将 .class 文件读进内存）；
- 将字节流的静态存储结构转化为运行时的数据结构；
- 在内存中生成该类的 Class 对象；
  - HotSpot 虚拟机把这个对象放在方法区，非 Java 堆

###  类-分类

- 非数组类
  - 系统提供的引导**类加载器**
  - 用户自定义的**类加载器**
- 数组类
  - 不通过类加载器，由 **Java 虚拟机**直接创建
  - 创建动作由 newarray 指令触发，new 实际上触发了 `[L全类名` 对象的初始化
  - 规则
    - 数组元素是引用类型
      - 加载：递归加载其组件
      - 可见性：与引用类型一致
    - 数组元素是非引用类型
      - 加载：与引导类加载器关联
      - 可见性：public

## 验证

- **目的：** 确保 .class 文件中的字节流信息符合虚拟机的要求。
- 4 个验证过程：
  - 文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” `0xCAFEBABE`
  - 元数据验证：保证字节码描述信息符号 Java 规范（语义分析）
  - 字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）
  - 符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验
- 这个操作虽然重要，但不是必要的，可以通过 `-Xverify:none` 关掉



## 准备(重点)

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144141)

- **描述：** 为 **static 变量**在**方法区**分配内存。(主要是为**类变量**（注意，不是实例变量）分配内存，并且赋予初值。)

- static 变量准备后的初始值：

  - ```
    public static int value = 123;
    ```

    - 准备后为 0，value 的赋值指令 putstatic 会被放在 `<clinit>()` 方法中，`<clinit>()`方法会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123。

  - ```
    public static final int value = 123;
    ```

    - 准备后为 123，因为被 `static final` 赋值之后 value 就不能再修改了，所以在这里进行了赋值之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好。

- 比如**8种基本类型**的初值，默认为0；**引用类型的初值**则为null；常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323142553.jpeg)





## 解析(重点)

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323143731)

- 描述：

  将常量池中的 “符号引用” 替换为 “直接引用”。

  - 在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。
  - 什么是 “符号引用” 和 “直接引用” ？
    - 符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。
    - 直接引用：直接指向被**引用目标在内存中的位置的指针**等，也就是说，引用的目标一定存在于内存中。



### 符号引用

符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。符号引用于JVM内存布局无关。

> 符号引用的作用是在编译的过程中，JVM并不知道引用的具体地址，所以用符号引用进行代替，而在解析阶段将会将这个符号引用转换为真正的内存地址。

### 直接引用

可以是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。有了直接引用，那么引用的目标必定已经在虚拟机内存中

直接引用可以理解为：指向**类对象、变量、方法**的指针、指向**实例**的指针和一个**间接定位**到对象的对象句柄。

举例：

```
public class Test{
   public static void main(String[] args) {
     String s="adc";
     System.out.println("s="+s);
   }
}
```

上面这段代码的变量`s`在编译时会被解析成为符号引用，符号引用的标志是`astore_<n>`，对应下图的`astore_1`

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144913)

我们在方法里定义了一个局部变量`s`，把它指向`adc`存放的地址，但是在编译时`s`并不知道`adc`的地址，JVM将变量`s`与`astore_1`对应起来，`astore_1`的含义是将操作数栈顶的`adc`保存回索引为`1`的局部变量表中，此时访问变量`s`就会读取局部变量表索引值为`1`中的数据。所以局部变量`s`就是一个符号引用。

下面这段代码的字符串被解析为直接引用

```
public class Test{
    public static void main(String[] args) {
        System.out.println("s="+"adc");
    }
}
```

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144940)

我们可以看到字节码指令`ldc`直接将`s=abc`这一字符串从常量池中推送到栈，然后下一条字节码指令`invokevirtual`代表调用实例方法，并没有将字符串存入局部变量表中，所以这里的`s=abc`就是一个直接引用。

总结一下：符号引用是指在编译时无法确定对象的内存地址，所以必须使用一个符号引用去对应局部变量表中的一个特定位置，然后在解析阶段将该变量的值或引用地址保存回局部变量表中，此后访问该变量值都会从局部变量表对应的位置查找该值；而直接引用是在编译时就可以确定。







解析阶段是虚拟机**将常量池内的符号引用替换为直接引用**的过程。**符号引用**就是一组符号来描述目标，可以是任何字面量；**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。下面将讲解前面4种引用的解析过程。

- **类或接口的解析**

假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机需要以下3个步骤：

（1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。

（2）如果C是一个数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型。

（3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。

- **字段解析**

要解析一个未被解析过的字段符号引用，首先将会对字段所属的类或接口的符号引用进行解析。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：

（1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

（2）否则，如果在C中实现了接口，就会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

（3）否则，如果C不是java.lang.Object的话，就会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

（4）否则，查找失败，抛出**java.lang.NoSuchFieldError**异常。

最后，如果查找过程成功返回了直接引用，就会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出**java.lang.IllegalAccessError**异常。

- **类方法解析**

类方法解析也需要先解析出类方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：

（1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现C是个接口，直接抛出异常。

（2）否则，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

（3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

（4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，查找结束，抛出异常。

（5）否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`异常。

最后，如果查找过程成功返回了直接引用，就会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出`java.lang.IllegalAccessError`异常。

- **接口方法解析**

接口方法解析也需要先解析出接口方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：

（1）如果在接口方法表中发现C是个类而不是接口，直接抛出异常。

（2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

（3）否则，在接口C的父接口中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

（4）否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`异常。

由于接口中的所有方法默认都是`public`的，所以不存在访问权限的问题。



## 初始化(重点)

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323143822)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210401104840.png)





- **描述：** 执行类构造器 `<clinit>()` 方法的过程。 (这个阶段主要是对**类变量初始化**，是执行类构造器的过程。换句话说只对static修饰的变量或语句进行初始化)

  如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

  如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行

- `<clinit>()` 方法

  - 包含的内容：

    - 所有 static 的赋值操作；
    - static 块中的语句；

  - ```
    <clinit>()
    ```

    方法中的语句顺序：

    - 基本按照语句在源文件中出现的顺序排列；
    - 静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，但不能访问。

  - 与

     

    ```
    <init>()
    ```

     

    的不同：

    - 不需要显示调用父类的 `<clinit>()` 方法；

    - 虚拟机保证在子类的

       

      ```
      <clinit>()
      ```

       

      方法执行前，父类的

       

      ```
      <clinit>()
      ```

       

      方法一定执行完毕。

      - 也就是说，父类的 static 块和 static 字段的赋值操作是要先于子类的。

  - 接口与类的不同：

    - 执行子接口的 `<clinit>()` 方法前不需要先执行父接口的 `<clinit>()` 方法（除非用到了父接口中定义的 public static final 变量）；

  - 执行过程中加锁：

    - 同一时刻只能有一个线程在执行 `<clinit>()` 方法，因为虚拟机要保证在同一个类加载器下，一个类只被加载一次。

  - 非必要性：

    - 一个类如果没有任何 static 的内容就不需要执行 `<clinit>()` 方法。

*注：初始化时，才真正开始执行类中定义的 Java 代码。*



### 类加载的时机(类合适被初始化)



### 类初始化顺序



# 类初始化详解

# 初始化---类加载的时机(类何时初始化)

JVM 会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用呢？

只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源



## 引用(主动引用&被动引用)

 ### 主动引用

- 遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：
  - 使用 new 实例化对象；
  - 读取或设置一个类的 static 字段（被 final 修饰的除外）；
  - 调用类的静态方法。
- 对类进行反射调用；
- 初始化一个类时，其父类还没初始化（需先初始化父类）；
  - 这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。
- 虚拟机启动，先初始化包含 main() 函数的主类；
- JDK 1.7 动态语言支持：一个 java.lang.invoke.MethodHandle 的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic



### 被动引用

- 被动引用
  - 通过子类引用父类静态字段，不会导致子类初始化；
  - `Array[] arr = new Array[10];` 不会触发 Array 类初始化；
  - `static final VAR` 在编译阶段会存入调用类的常量池，通过 `ClassName.VAR` 引用不会触发 ClassName 初始化。



#### 被动引用示例一

```
package com.lijiankun24.classpractice;

public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }

    public static int value = 24;
}

public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}

public class Demo {

    public static void main(String[] args){
        System.out.println("The value is " + Subclass.value);
    }
}
```

结果：

```
SuperClass init!
The value is 24
```

对于静态字段，只有直接定义这个字段的类会被初始化，如果是通过子类引用父类的字段，父类会被初始化，子类不一定会被初始化，子类会不会被初始化 JVM 虚拟机规范并没有明确规定，取决于虚拟机的具体实现

####  被动引用示例二

```
public class SubClass {
    static {
        System.out.println("SubClass init!");
    }
}

public class Demo {

    public static void main(String[] args){
        SubClass[] subClassArray = new SubClass[10];
    }
}
```

上面代码运行之后，并不会输出 "SubClass init!"，因为在上面 Demo#main() 方法中，并没有初始化 SubClass 类，而是初始化了一个 SubClass[] 数组类，SubClass[] 数组类代表了一个元素类型为 SubClass 的一维数组，继承自 Object 类，由 newarray 字节码创建。

#### 被动引用示例三

```
public class Constant {

    static {
        System.out.println("Constant init!");
    }

    public static final String VALUE = "Hello World!";
}

public class Demo {

    public static void main(String[] args){
        System.out.println(Constant.VALUE);
    }
}
```

上面代码运行之后也并不会输出 "Constant init!"，因为这涉及到一个概念 ---- “常量传播优化”。虽然在代码中，Demo 类引用了 Constant 类中的常量 VALUE，但是在编译阶段，会将 VALUE 的实际值 "Hello World!" 放到 Demo 类中的常量池中，Demo 类每次使用 "Hello World!" 常量的时候都会从自己的常量池中去找。Demo 类不会持有 Constant 类的符号引用，所以 Constant 类也并不会被初始化。

#### 

 

## Java对象创建的几种方式

（new、反射、克隆 ）

- new Object()，以new方式调用构造函数创建对象；
- 使用class类的newInstance()方法（反射）；
- 使用Constructor类的newInstance()方法（反射）；
- 使用clone()方法创建对象（克隆）；
- 使用序列化|反序列化机制创造对象（深克隆）；



## 类的显式加载和隐式加载

### 显式加载

- 调用 `ClassLoader#loadClass(className)` 或 `Class.forName(className)`。
- 两种显示加载 .class 文件的区别：
  - `Class.forName(className)` 加载 class 的同时会初始化静态域，`ClassLoader#loadClass(className)` 不会初始化静态域；
  - Class.forName 借助当前调用者的 class 的 ClassLoader 完成 class 的加载。



### 隐式加载

- new 类对象；
- 使用类的静态域；
- 创建子类对象；
- 使用子类的静态域；
- 其他的隐式加载，在 JVM 启动时：
  - BootStrapLoader 会加载一些 JVM 自身运行所需的 Class；
  - ExtClassLoader 会加载指定目录下一些特殊的 Class；
  - AppClassLoader 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件



# 初始化---类初始化顺序

程序的执行顺序为：
如果类还没有被加载：
1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。
2、执行子类的静态代码块和静态变量初始化。
3、执行父类的实例变量初始化
4、执行父类的构造函数
5、执行子类的实例变量初始化
6、执行子类的构造函数

```
public class test {                         //1.第一步，准备加载类

    public static void main(String[] args) {
        new test();                         //4.第四步，new一个类，但在new之前要处理匿名代码块        
    }

    static int num = 4;                    //2.第二步，静态变量和静态代码块的加载顺序由编写先后决定 

    {
        num += 3;
        System.out.println("b");           //5.第五步，按照顺序加载匿名代码块，代码块中有打印
    }

    int a = 5;                             //6.第六步，按照顺序加载变量

    { // 成员变量第三个
        System.out.println("c");           //7.第七步，按照顺序打印c
    }

    test() { // 类的构造函数，第四个加载
        System.out.println("d");           //8.第八步，最后加载构造函数，完成对象的建立
    }

    static {                              // 3.第三步，静态块，然后执行静态代码块，因为有输出，故打印a
        System.out.println("a");
    }

    static void run()                    // 静态方法，调用的时候才加载// 注意看，e没有加载
    {
        System.out.println("e");
    }
}
```

一般顺序：静态块（静态变量）——>成员变量——>构造方法——>静态方法
1、静态代码块（只加载一次） 2、构造方法（创建一个实例就加载一次）3、静态方法需要调用才会执行，所以最后结果没有e

![这里写图片描述](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323142258.jpeg)

```
public class Print {

     public Print(String s){
         System.out.print(s + " ");
     }
 }
 
 
 public class Parent{

     public static Print obj1 = new Print("1");

     public Print obj2 = new Print("2");

     public static Print obj3 = new Print("3");

     static{
         new Print("4");
     }

     public static Print obj4 = new Print("5");

     public Print obj5 = new Print("6");

     public Parent(){
         new Print("7");
     }

 }


public class Child extends Parent{

     static{
         new Print("a");
     }

     public static Print obj1 = new Print("b");

     public Print obj2 = new Print("c");

     public Child (){
         new Print("d");
     }

     public static Print obj3 = new Print("e");

     public Print obj4 = new Print("f");

     public static void main(String [] args){
         Parent obj1 = new Child ();
         Parent obj2 = new Child ();
     }
 }
```

执行main方法，程序输出顺序为： 1 3 4 5 a b e 2 6 7 c f d 2 6 7 c f d 







# Java对象

## Java对象的创建过程

参考本章：Java堆中对象分配、布局和访问的全过程



```
instance = new Singleton();


memory = allocate(); //1.分配内存空间
ctorInstance(memory); //2.初始化对象
instance = memory; //3.设置instance指向刚分配的内存地址
由于JVM的重排序，又可能步骤2和步骤3的过程互换。
```

https://www.codenong.com/cs105431209/

创建过程分为五步：

1. **类加载检查**
   - 当Java虚拟据遇到一条new指令时，首先检查这个指令中的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析，初始化。如果没有，则先执行相应的类加载过程。
2. **分配内存空间**
   - 当类加载检查通过之后，就应该为对象分配内存空间。对象所需的内存大小在类加载完成后就能确定。
   - 分配的方式主要有**指针碰撞**和**空闲列表**两种方式，**选择哪种分配方式由Java堆是否规整来决定，而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的**
3. **初始化零值**
   - 当内存分配完毕之后，就应该将分配到的内存空间初始化为零值(不包括对象头)。
   - 这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序可以访问到这些字段的数据类型所对应的零值。
4. **设置对象头**
   - 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如元数据信息，哈希码，GC分代年龄等信息）
5. **执行init方法**
   - 执行new指令之后，紧接着会执行init方法，把对象按照程序员的意愿进行初始化。这样一个对象才算是完全产生出来。
   - 

### 详细

#### Java对象创建的过程

1. **在堆内存中开辟一块空间；**

2. **给开辟的空间分配一个地址；**

3. **对所有非静态成员加载到所开辟的空间；**

4. **对非静态成员变量进行默认值初始化；**

5. **调用构造函数；**

6. **构造函数入栈执行时，先隐式三步（super()、初始化、构造代码块），再执行构造函数代码；**

   > 构造函数和构造器的执行顺序：
   >
   > 1. 父类的类构造器<clinit>()
   > 2. 子类的类构造器<clinit>()
   > 3. 父类的成员变量和实例代码块
   > 4. 父类的构造函数
   > 5. 子类的成员变量和实例代码块
   > 6. 子类的构造函数

7. **构造函数执行完弹出栈后，把空间分配的地址给引用对象；**

核心步骤：**检查类释放被加载——为新生对象分配内存——初始化设定零值——必要的设置——执行<init>方法**



## Java对象实例初始化

涉及三种执行对象的初始化：

- **实例变量初始化**：实例变量直接赋值。

- **实例代码块初始化**：实例代码块赋值，编译器会将其中的代码放在类的构造函数中去，并且这些代码会被放在超类构造函数调用语句之后，构造函数本身代码之前；这也是为什么Java要求构造函数第一句必须是super();即超类的类构造函数的调用语句；Java要求实例化之前必须实例化其父类，以保证完整性。

- **构造函数初始化**：

  ```
  public class A{
      private int i=2;//实例变量初始化
      
      {
          i++;//实例代码块初始化
      }
      
      public A(){}//构造函数初始化
  }
  ```

  



## 内存分配的两种方式

- **指针碰撞**
  - 用过的内存全部整合到一边，没用过的放在另一边，中间有一个分界指针。分配时，只需要向着没有用过的方向，将该指针移动对象内存大小的位置即可。
  - GC收集器：Serial，ParNew
  - \- **适用于堆内存规整的情况下**(没有内存碎片)。
- **空闲列表**
  - 虚拟机会维护一个列表，记录上哪些内存块是可用的。再分配时，从列表中找到一块足够的空间划分给对象实例，并更新列表上的记录。
  - GC收集器：CMS
  - **适用于堆内存不规整的情况**



## 内存分配并发问题

- **CAS+失败重试**
  - CAS是乐观锁的一种实现方式，虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。
- **TLAB**
  - 每个线程在Java堆中预先分配一小块内存，哪个线程要分配内存，就在哪个线程的TALB上分配，当对象大于TALB中的剩余内存，或TALB的内存用尽时，在采用上面的CAS进行内存分配。



# 面试题

## new一个对象有哪两个过程？

Java在new一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名来加载。**加载并初始化类**完成后，再进行**对象的创建**工作。 我们先假设是第一次使用该类，这样的话new一个对象就可以分为两个过程：加载并初始化类和创建对象



## 简单描述一下 Person person = new Person() 对象实例化过程。最好有类加载过程

![这里写图片描述](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210510111503.png)





1.首先虚拟机读取指定的路径下的Person.class文件，并**加载至内存**（如果该对象有直接父类则会先加载父类）—-**方法区** 
 2.按顺序执行父类的static代码块和static变量，再执行子类的static代码块和static变量 —-**方法区** 
 3.创建Person对象，在堆内存开辟空间分配堆内存地址 —-**堆中** 
 4.将父类对象的属性和代码块默认初始化（int类型为0，String类型为null）；对父类对应的构造函数进行初始化 —-**栈中** 
 5.将子类对象的属性和代码块默认初始化（int类型为0，String类型为null）；对子类对应的构造函数进行初始化 —-**栈中** 
 6.进行子类构造函数的特定初始化例如声明赋值变量（这种情况较少） —-**栈中** 
 7.声明一个**person对象引用**—-**栈中** 
 8.初始化完毕，栈中的person对象引用**指向堆内存中Person对象**。 

