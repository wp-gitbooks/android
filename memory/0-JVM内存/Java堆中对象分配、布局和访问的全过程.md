# 参考

https://www.cnblogs.com/aduner/p/14746105.html



# 前言

**对象**是Java中最常被提到的概念，也是Java的灵魂，Java中一切皆是对象。

JVM是Java的根基，理解灵魂与根基是如何融合的，对于理解Java本身至关重要。

# 对象的创建

对象的创建从Java语言层面上，往往就是一个简单的`new`即可搞定，而深入JVM的底层，可就复杂的多了。

JVM中对象的创建过程，分为如下5步，如图：

![image-20210510113200422](http://wupan.dns.army:5000/wupan/Typora-Picgo-Gitee/raw/branch/master/img/20210510113220.png)



## 类加载检查

虚拟机遇到一条 `new` 指令后，会执行如下几个步骤：

1. 首先将去检查这个**指令的参数**是否能在**常量池中定位**到这个**类的符号引用**。
2. 检查这个符号引用代表的类是否已被**加载过**、**解析过**、**初始化过**。
3. 如果没有，那必须先执行相应的类加载过程。
4. 确定对象所需的内存大小。
5. **类加载检查**通过后，进入下一步骤，为新生对象**分配内存**。

## 分配内存

为对象分配空间相当于分田地，就是将空余的内存划分一块给对象。

由于不同的JVM虚拟机，Java堆的内存规整情况是不同的，所以分配方式上也会有一定区别。

> Java 堆是否规整，由JVM所采用的垃圾收集器是否带有**压缩整理功能决定**的

### 内存空间分配方式

#### 指针碰撞

Java堆中内存是**规整（无内存碎片）**时使用，即垃圾收集器**有压缩整理功能**时。

原理就是将用过的内存放在一块，没用的放一块，**中间用指针做标识**，分配的时候将**指针向空闲内存区域移动**。

#### 空闲列表

Java堆中内存**不规整**，即垃圾收集器**无压缩整理功能**时。

使用内存和空闲内存相互交错，JVM需维护一个列表，记录上哪些内存是可用的，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

两者具像化呈现如图：

![image-20210510113259250](http://wupan.dns.army:5000/wupan/Typora-Picgo-Gitee/raw/branch/master/img/20210510113319.png)



## 并发时的内存分配

创建对象是很频繁的事，并发创建对象的时候有一个很重要的问题，就是**线程安全**。

如：程序中创建对象A和对象B，底层VM给A对象分配内存，**指针没来及修改**，对象B同时使用原来的指针分配内存。

JVM一般采用一下两种方式来保障线程安全。

#### 同步处理：CAS

CAS 是**乐观锁**的一种实现方式。

所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。

**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**

#### 本地线程分配缓冲：TLAB

- 为**每一个线程**预先在 Eden 区分配一块儿内存，即为TLAB
- JVM 在给线程中的对象分配内存时，**首先在 TLAB 分配**
- 当对象大于 TLAB 中的剩余**内存不足或已用尽时**，再采用上述的 CAS 进行内存分配

> 更多关于CAS的内容可以参考博主的另一篇文章[**Java并发/多线程-CAS原理分析**](https://www.cnblogs.com/aduner/p/14296008.html)

## 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）

这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

## 设置对象头

对象头是虚拟机对对象进行必要的设置

对象头存放了关于对象的各种信息如：

- 对象是哪个类的实例
- 如何才能找到类的元数据信息
- 对象的哈希码
- 对象的 GC 分代年龄
- ……

根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

## 执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生

从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。

所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

# 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域。

**对象头**

对象头上面已经介绍过了，其实主要就是分为两类：

- 用于存储对象自身的运行时数据
- 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例

**实例数据**

这部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

**对齐填充**

对齐填充不是必然存在的，没有实际意义，就是用来补位的。

因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，对象的大小必须是 8 字节的整数倍。

所以，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

# 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。

对象的访问方式由虚拟机实现而定，目前主流的访问方式有如下两种方式

## 使用句柄

Java 堆中将会**划分出一块内存来作为句柄池**，reference 中存储的就是对象的句柄地址，而句柄中包含了对象**实例数据与类型数据**各自的具体地址信息，如图：

[![image-20210508181954450](http://wupan.dns.army:5000/wupan/Typora-Picgo-Gitee/raw/branch/master/img/202304061100032.jpeg)](https://tva1.sinaimg.cn/large/008i3skNly1gqb6v0r4zej31660qcgor.jpg)

## 直接指针

如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

![image-20210508181849041](http://wupan.dns.army:5000/wupan/Typora-Picgo-Gitee/raw/branch/master/img/202304061100033.jpeg)

## 二者对比

使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

使用直接指针访问方式最大的好处就是**速度快**，它节省了一次指针定位的时间开销。

> 参考：《深入理解JVM虚拟机》第三版（吹爆）

