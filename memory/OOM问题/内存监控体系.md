# 内存监控体系

## 图片

1、图片库统一

2、设备分级优化策略



### 线下大图片检测

#### ARTHook优雅检测大图

**ARTHook**，即 **挂钩，用额外的代码勾住原有的方法，以修改执行逻辑**，主要可以用于以下四个方面：

- 1）、**AOP编程**
- 2）、**运行时插桩**
- 3）、**性能分析**
- 4）、**安全审计**



### 线下图片重复检测



### 建全局的线上Bitmap监控







## 线上应用内存监控体系



### 常规内存监控



### 低内存监控



### 内存监控指标

为了准确衡量内存性能，我们需要引入一系列的内存监控指标，如下所示：

#### 1 发生频率

#### 2 发生时各项内存使用状况

#### 3 发生时App的当前场景

#### 4 内存异常率

```
内存 UV 异常率 = PSS 超过 400MB 的 UV / 采集UV
PSS 获取：调用 Debug.MemoryInfo 的 API 即可
复制代码
```

如果出现 **新的内存使用不当或内存泄漏** 的场景，这个指标会有所 **上涨**。

#### 5 触顶率

```
内存 UV 触顶率 = Java 堆占用超过最大堆限制的 85% 的 UV / 采集UV
复制代码
```

计算触顶率的代码如下所示：

```
long javaMax = Runtime.maxMemory();
long javaTotal = Runtime.totalMemory();
long javaUsed = javaTotal - runtime.freeMemory();
float proportion = (float) javaUsed / javaMax;
复制代码
```

如果超过 **85% 最大堆** 的限制，**GC** 会变得更加 **频发**，容易造成 **OOM 和 卡顿**。

### 4 小结

在具体实现的时候，**客户端** 尽量只负责 **上报数据**，而 **指标值的计算** 可以由 **后台** 来计算。这样便可以通过 **版本对比** 来**监控**是否有 **新增内存问题**。因此，**建立线上内存监控的完整方案** 至少需要包含以下**四点**：

- 1）、**待机内存、重点模块内存、OOM率**。
- 2）、**整体及重点模块 GC 次数、GC 时间**。
- 3）、**增强的 LeakCanry 自动化内存泄漏分析**。
- 4）、**低内存监控模块的设置**。





## 建立全局的线程监控组件

**每个线程初始化都需要 mmap 一定的栈大小，在默认情况下初始化一个线程需要 mmap 1MB 左右的内存空间**。

在 **32bit** 的应用中有 **4g 的 vmsize**，**实际**能使用的有 **3g+**，这样一个进程 **最大能创建的线程数** 可以达到 **3000个**，但是，**linux 对每个进程可创建的线程数也有一定的限制（/proc/pid/limits）**，并且，**不同厂商也能修改这个限制**，超过该限制就会 OOM。

因此，对线程数量的限制，在一定程度上可以 **有效地避免 OOM 的发生**。那么，实现一套 **全局的线程监控组件** 便是 **刻不容缓** 的了。

### 全局线程监控组件的实现原理

**在线下或灰度的环境下通过一个定时器每隔 10分钟 dump 出应用所有的线程相关信息，当线程数超过当前阈值时，则将当前的线程信息上报并预警**






## GC 监控组件搭建

通过 **Debug.startAllocCounting** 来监控 **GC** 情况，注意有一定 **性能影响**。

在 **Android 6.0 之前** 可以拿到 **内存分配次数和大小以及 GC 次数**，其对应的代码如下所示：

```
long allocCount = Debug.getGlobalAllocCount();
long allocSize = Debug.getGlobalAllocSize();
long gcCount = Debug.getGlobalGcInvocationCount();
复制代码
```

并且，在 **Android 6.0 及之后** 可以拿到 **更精准** 的 **GC** 信息：

```
Debug.getRuntimeStat("art.gc.gc-count");
Debug.getRuntimeStat("art.gc.gc-time");
Debug.getRuntimeStat("art.gc.blocking-gc-count");
Debug.getRuntimeStat("art.gc.blocking-gc-time");
复制代码
```

对于 **GC 信息的排查**，我们一般关注 **阻塞式GC的次数和耗时**，因为它会 **暂停线程**，可能导致应用发生 **卡顿**。建议 **仅对重度场景使用**。





## 建立线上 OOM 监控组件：Probe

美团的 Android **内存泄漏自动化链路分析组件** **Probe** 在 **OOM** 时会生成 **Hprof 内存快照**，然后，它会通过 **单独进程** 对这个 **文件** 做进一步 **分析**。

### Probe 组件的缺陷及解决方案

它的缺点比较多，具体为如下几点：

- 1、**在崩溃的时候生成内存快照容易导致二次崩溃**。
- 2、**部分手机生成 Hprof 快照比较耗时**。
- 3、**部分 OOM 是由虚拟内存不足导致**。

在实现自动化链路分析组件 Probe 的过程中主要要解决两个问题，如下所示：

#### 1、链路分析时间过长

- 1）、使用**链路归并**：将具有 **相同层级与结构** 的链路进行 **合并**。
- 2）、使用 **自适应扩容法**：**通过不断比较现有链路和新链路，结合扩容因子，逐渐完善为完整的泄漏链路**。

#### 2、分析进程占用内存过大

**分析进程占用的内存** 跟 **内存快照文件的大小** 不成正相关，而跟 **内存快照文件的 Instance 数量** 呈 **正相关**。所以在开发过程中我们应该 **尽可能排除不需要的Instance实例**。

### Probe 分析流程揭秘

Probe 的 **总体架构图** 如下所示：

![image](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbb5e763b52642feabeaf2c53fe9ad2a~tplv-k3u1fbpfcp-zoom-1.image)

而它的整个分析流程具体可以细分为八个步骤，如下所示：

#### 1 hprof 映射到内存 => 解析成 Snapshot & 计数压缩：

解析后的 Snapshot 中的 Heap 有四种类型，具体为：

- 1）、**DefaultHeap**
- 2）、**ImageHeap**
- 3）、**App Heap**：包括 **ClassInstance、ClassObj、ArrayInstance、RootObj**。
- 4）、**System Heap**

**解析完** 后使用了 **计数压缩策略**，对 **相同的 Instance** 使用 **计数**，以 **减少占用内存。超过计数阈值的需要计入计数桶（计数桶记录了 丢弃个数 和 每个 Instance 的大小）**。

#### 2 生成 Dominator Tree。

#### 3 计算 RetainSize。

#### 4 生成 Reference 链 && 基础数据类型增强:

如果对象是 **基础数据类型**，会将 **自身的 RetainSize 累加到父节点** 上，将 **怀疑对象** 替换为它的 **父节点**。

#### 5 链路归并。

#### 6 计数桶补偿 & 基础数据类型和父节点融合：

**使用计数补偿策略计算 RetainSize，主要是 判断对象是否在计数桶中，如果在的话则将 丢弃的个数和大小补偿到对象上，累积计算RetainSize，最后对 RetainSize 排序以查找可疑对象**。

#### 7 排序扩容。

#### 8 查找泄露链路。



## 设置内存兜底策略

设置内存兜底策略的目的，是为了 **在用户无感知的情况下，在接近触发系统异常前，选择合适的场景杀死进程并将其重启，从而使得应用内存占用回到正常情况**。

通常执行内存兜底策略时至少需要满足六个条件，如下所示：

- 1）、**是否在主界面退到后台且位于后台时间超过 30min**。
- 2）、**当前时间为早上 2~5 点**。
- 3）、**不存在前台服务（通知栏、音乐播放栏等情况）**。
- 4）、**Java heap 必须大于当前进程最大可分配的85% || native内存大于800MB**。
- 5）、**vmsize 超过了4G（32bit）的85%**。
- 6）、**非大量的流量消耗（不超过1M/min） && 进程无大量CPU调度情况**。

只有在满足了以上条件之后，我们才会去**杀死当前主进程并通过 push 进程重新拉起及初始化**。



