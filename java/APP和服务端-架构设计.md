架构[因人而异](https://link.zhihu.com/?target=https%3A//www.baidu.com/s%3Fwd%3D%E5%9B%A0%E4%BA%BA%E8%80%8C%E5%BC%82%26tn%3D24004469_oem_dg%26rsv_dl%3Dgh_pl_sl_csd)，不同的架构师大多会有不同的看法；架构也因项目而异，不同的项目需求不同，相应的架构也会不同。然而，有些东西还是通用的，是所有架构师都需要考虑的，也是所有项目都会有的需求，比如API如何设计？架构如何分层？开发环境和生产环境如何分离？这几年，我负责研发过的App，有餐饮类的、社交类的、智能家居类的、电商类的、新闻媒体类的等等。当有了一定的经验之后，你总会有一些自己的心得体会。而以下内容就是根据我的这些经历提炼出来的关于以上几个问题方面的经验总结，内容不多，旨在抛砖引玉。



# 1. 从API开始

一个App，最核心的东西，其实就是数据，而数据的主要来源，就是API。我之前负责的项目，因为API的坑已经受过了不少苦，因此，之后对App项目的架构设计我都会先从API开始。

## 1.1 制定安全机制

设计API第一个需要考虑的是API的安全机制。我负责的上一个项目，因为API的安全问题，就被人攻击了两次。之后经过分析，主要存在两个漏洞：一是因为缺少对调用者进行安全验证的方式，二是因为数据传输不够安全。那么，制定API的安全机制，主要就是为了解决这两个问题：

- 保证API的调用者是经过自己授权的App；
- 保证数据传输的安全。

### 第一个问题的解决方案，我主要采用设计签名的方式。

对每个客户端，Android、iOS、WeChat，分别分配一个AppKey和AppSecret。需要调用API时，将AppKey加入请求参数列表，并将AppSecret和所有参数一起，根据某种签名算法生成一个签名字符串，然后调用API时把该签名字符串也一起带上。服务端收到请求之后，根据请求中的AppKey查询相应的AppSecret，按照同样的签名算法，也生成一个签名字符串。当服务端生成的签名和请求带过来的签名一致的时候，那就表示这个请求的调用者是经过自己授权的，证明这个请求是安全的。而且，每个端都有一个Key，也方便不同端的标识和统计。为了防止AppSecret被别人获取，这个AppSecret一般写死在代码里面。另外，签名算法也需要有一定的复杂度，不能轻易被别人破解，最好是采用自己规定的一套签名算法，而不是采用外部公开的签名算法。另外，在参数列表中再加入一个时间戳，还可以防止部分重放攻击。



### 第二个问题的解决方案，主要就是采用HTTPS了。

HTTPS因为添加了SSL安全协议，自动对请求数据进行了压缩加密，在一定程序可以防止监听、防止劫持、防止重发，主要就是防止中间人攻击。苹果从iOS9开始，默认就采用HTTPS了。而关于在Android中如何使用HTTPS，Google官方也给出了很多安全建议。不过，大部分App并没有按照安全建议去实现，主要就是没有对SSL证书进行安全性检查，这就成为了一个很大的漏洞，中间人利用此漏洞用假证书就可以通过检查，从而可以劫持到所有数据了。因此，为了安全考虑，建议对SSL证书进行强校验，包括签名CA是否合法、域名是否匹配、是不是自签名证书、证书是否过期等。



## 1.2 接口协议标准化

API返回的数据，一般都是采用JSON格式进行传输。然而，JSON的值只有六种数据类型：

Number：整数或浮点数

String：字符串

Boolean：true 或 false

Array：数组包含在方括号[]中

Object：对象包含在大括号{}中

Null：空类型

关于API的坑有大部分就是因为JSON数据和实体对象转化时出错导致的，而且是[各种各样](https://link.zhihu.com/?target=https%3A//www.baidu.com/s%3Fwd%3D%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%26tn%3D24004469_oem_dg%26rsv_dl%3Dgh_pl_sl_csd)的错误都有，其中不乏有一些很奇葩的错误。



### 1.2.1 最麻烦的就是处理Date类型



因为JSON本身没有Date类型，因此，JSON库将Date类型的数据序列化时会转为String。这时，不同环境，不同平台，以及用不同的JSON解析库，转换后的结果经常会不同。比如，你在开发机上可能得到的结果是”2016-1-1 17:11:11”，但放到服务器后结果却变成了“Jan 1,2016 5:11:11 PM” ，客户端进行反序列化时无疑会失败。后来，我取消了所有Date类型，统一采用时间戳表示，就再没有转化的烦恼了。

### 1.2.2 接口的开发人员有时候会将一些数据错误地转换为了String

导致客户端使用时因类型错误而异常。例如，本来是数字的1，被转成了”1”，客户端做运算时就会出错，或用switch判断时也会出错，或其他无法转换的情况发生时；例如，为空时JSON正确地表示应该是null，但如果转为了String就变成了”null”，那问题就来了，我遇到的因为这个错误的转换导致的程序奔溃已经好几次了，第一次的时候，查了一整天才定位到问题所在。

### 1.2.3 很多时候还会出现不同接口同一个意思的参数名称却不同

比如，对于有分页数据的接口，一般都有当前页的参数，A开发人员可能将参数命名为currentPage，第一页是从0开始；B开发人员在另一个接口则命名为currPage，第一页却从1开始；C开发人员在另一个接口又命名为presentPage，第一页又是从0开始。客户端的开发人员看到也是醉了。

每个技术团队一般都会有一份接口协议文档，主要内容包括每个接口的描述、入参、输出结果等，但一般并不严谨，很多地方没有统一标准，从而容易出现很多坑。因此，有一份统一标准且严格执行的接口协议非常重要。协议的内容除了规定每个接口，包括接口中每个数据具体的数据类型，还需要规定一套共用的数据字典，以及其他需要统一定义的信息，比如签名算法等。一旦有了这份统一标准且严格执行的接口协议，很多问题都将迎刃而解。



### 1.2.4 接口版本控制

我们已经不止一次因为接口发生变动而导致旧版本的App出错的问题，而且变动不一定是修改了接口本身，有可能是底层增加了一种新的数据结构，接口把新数据也返回给客户端了，但客户端旧版本是解析不了的，从而就导致出错了。

为了解决接口的兼容性问题，需要做好接口版本控制。实现上，一般有两种做法：

每个接口有各自的版本，一般为接口添加个version的参数；

整个接口系统有统一的版本，一般在URL中添加版本号，比如[http://api.domain.com/v2。](https://link.zhihu.com/?target=http%3A//api.domain.com/v2%E3%80%82)



平时小版本的更新，就采用第一种方式，我们的做法是根据不同版本号做不同分支处理。
大版本的更新，则用第二种方式，这时候，基本就是一套全新的接口系统了，跟旧版本是相对独立的。

当版本越来越多时，维护就会成为一个大问题，我们没那么多精力去维护所有版本，因此，太旧的版本一般就不会再维护了。这时候，如果有用户还在使用即将废弃的旧版本，需要提醒用户升级到新版本。



# 2. 架构分层

API的设计完成之后，接下来我就会考虑App项目的整体架构了。整体如何架构，我也曾经做过不少尝试。早期的时候，Android就是将所有操作都放在Activity里完成，包括界面数据处理、业务逻辑处理、调用API。后来发现Activity越来越臃肿，代码越来越复杂，很难维护。于是就开始思考如何拆分，如何才能做到松耦合高内聚。

前面也说过，一个App的核心就是数据，那么，从App对数据处理的角色划分出发，最简单的划分就是：数据管理、数据加工、数据展示。

相应的也就有了三层架构：数据层、业务层、展示层。

它们之间的关系如下图:

数据层：三层中的最底层，往下，它接入API；往上，它向业务层交付数据。
业务层：三层中的中间，属于数据的加工厂，将数据层提供上来的数据加工成展示层需要展示的数据。
展示层：三层中的最上层，主要就是将从业务层取得的数据展示到界面上。



![img](http://wupan.dns.army:5000/wupan/Typora-Picgo-Gitee/raw/branch/master/img/20210823112632.jpg)





## 2.1 数据层

数据层是数据管理者，主要任务就是封装API，并将数据结果交付给上层，中间会再加个数据缓存。整个主流程如下图：



![img](http://wupan.dns.army:5000/wupan/Typora-Picgo-Gitee/raw/branch/master/img/20210823112644.jpg)





业务层向数据层请求数据；
数据层检查缓存中有没有请求需要的数据；
如果有缓存数据，则直接返回缓存数据；
如果没有缓存数据，则从网络API获取数据，并将数据加入缓存，然后返回数据。

调用网络API时，还要判断网络状态，根据不同状态做不同处理。

如果网络不可用，就无需发起请求了。网络可用时，也要区分是连接WIFI还是连接移动网络。连接移动网络时，一般需要限制调用比较耗流量的请求。曾经，我们没有对移动网络状态下的请求进行限制，结果，测试时流量DuangDuangDuang地一下子就不见了十几M。连接WIFI时，则无需设置这种限制，而且还可以预先请求一些接口，比如请求当前分页数据时，可以将下一页的数据也预先请求。

缓存也需要缓存策略，不同的接口需要做不同的缓存处理。

首先，缓存只适用于获取数据的接口，对于修改数据的接口则不适用。
其次，不同接口缓存时间一般也不同，对于很少变动的数据缓存时间可以设置长一些，而频繁变动的数据缓存时间则比较短，甚至不进行缓存。
最后，缓存数据因为比较多，我们一般保存在数据库，而对于调用频率高、最新的数据，还会在内存中也拥有一份缓存，不过缓存时间比较短。

请求缓存数据时，会先检查内存缓存中有没有，有则直接将缓存的数据返回，没有才从数据库获取。



### 数据交付给业务层



这是整个数据层模块与外部交互的部分，当与外部交互的时候，一般都要符合面向接口编程的原则，因此只要提供开放的数据接口就可以了。对于接口的参数需要说明一下，上面提到的参数有appKey、version、currentPage这几个，还有签名sign、时间戳time，其实可以分为两类：系统参数和业务参数。像appKey、version、sign、time这些属于系统参数，而currentPage，或username之类的则属于业务参数。数据层开放的数据接口的参数只需要包含业务参数就可以了，业务层并不需要关心系统参数是什么，系统参数在数据层内部封装API时指定就可以了。

## 2.2 业务层

业务层是数据加工者，主要就是从数据层获取数据，然后经过业务逻辑处理后转化成展示层需要的数据。业务层因为夹在数据层和展示层中间，起着[承上启下](https://link.zhihu.com/?target=https%3A//www.baidu.com/s%3Fwd%3D%E6%89%BF%E4%B8%8A%E5%90%AF%E4%B8%8B%26tn%3D24004469_oem_dg%26rsv_dl%3Dgh_pl_sl_csd)的作用。也因此，业务层很容易沦落为只是一个数据的中转站，主要就是因为对业务层具体的作用和职责没有理解清楚。

这里用一个例子来说明业务层具体的工作吧，就举个用户注册的例子。用户注册时，界面上需要用户提供手机号、短信验证码、密码、确认密码。那么，最简单的操作就是，带上这些参数调用数据层的注册接口。好了，问题来了，注册接口并没有提供确认密码的参数。那好，调用注册接口之前先判断下密码和确认密码是否一致，不一致则返回错误提示给用户，一致了才调用注册接口。好了，第二个问题来了，用户等网络请求等了一段时间后，请求结果返回说手机号少了一位。下一次，又等了一段时间，这次又返回说手机号多了一位。就因为一个小错误要让用户等那么久，用户肯定有意见。后台也有意见，各种非法的请求都发过来，是嫌服务器压力不够大啊。那好，调用接口之前对这些参数做有效性检查吧，手机号要规范，短信验证码只能为六位数字，密码不能少于六位。终于注册成功了，第三个问题又来了，注册接口是没有返回用户的accessToken的，只有登录接口才会返回。让用户手动再登录一下？这用户体验不太好啊。正确的姿势应该是注册成功后再自动调用一次登录接口，如果因为网络问题第一次登录失败，后面还需要再自动调用多一次，如果还是调用失败，才让用户手动登录。



上面的例子中，对参数的有效性检查，注册成功后的自动登录，都属于业务逻辑的处理，也就是说都是业务层的工作。

业务层交付给展示层的数据也是通过接口的方式，不过，和数据层交付给业务层时不同的是：交付给展示层的数据应该是通过异步回调返回的。因为获取数据是一个比较耗时的任务，通过异步回调才不会阻塞UI主线程。



## 2.3 展示层

展示层作为数据展示者，它只要关心数据如何展示就可以了。不过，数据如何展示却不是那么简单。展示层是三层架构中最复杂的一层了，要考虑的东西远远多于其他两层，涉及的东西包括但不限于界面布局、屏幕适配、图片资源、文本资源、颜色资源等等。在开发一段时间后，展示层出现代码混乱是最常见的。因此，做好展示层，就需要保持高质量的代码。

### 要保持高质量代码，我觉得至少应该遵循几条基本的原则：

保持规范性：定义好开发规范，包括书写规范、命名规范、注释规范等，并按照规范严格执行；

保持单一性：布局就只做布局，内容就只做内容，各自分离好，每个方法、每个类，也只做一件事情；

保持简洁性：保持代码和结构的简洁，每个方法，每个类，每个包，每个文件，都不要塞太多代码或资源，感觉多了就应该拆分。



所谓无规矩不成方圆，展示层的设计，要从开发规范开始。一份好的开发规范，是保证代码有较高的可读性的基础。iOS方面，苹果已经有一套Coding Guidelines，主要属于命名方面的规范。当我们制定自己的开发规范时，首先就要遵守苹果的这份规范，在此基础上再加上自己的规范。Android方面，我也在我的博客中分享过一套（Android技术积累:开发规范），主要分为书写规范、命名规范、注释规范三部分。

最重要的不是开发规范的制定，而是开发规范的执行。如果没有按照开发规范去执行，那开发规范就等于形同虚设，那代码混乱的问题依然得不到解决。

说到单一性，面向对象设计中，有一个基本原则就是单一职责原则，它规定一个类应该只有一个发生变化的原因。保持单一性是减低耦合度的关键标准，其目的就是各方面的解耦。而我这里说的单一性不只是规定类的单一，也包括界面的单一、方法的单一、资源文件的单一等。

界面的单一，首先是界面的布局和界面的数据应该分离。另外，界面数据的获取和展示也应该分离。一句话，保持界面的单一性就是要保持界面上每个维度都做好分离，从界面的布局，到数据的获取，数据的检查，数据的展示。

方法的单一，则表现为一个方法是对一个行为的封装。行为又可以拆分为多个步骤，每个步骤其实也是更细化的行为。因此，方法嵌套方法是一种常态。那么，保持方法的单一性，关键不在于怎么定义这个方法的行为，而在于这个行为要怎么拆分成更细的行为。举个例子，通常在Activity的onCreate方法，做初始化操作，细分出来就分为了：控件的初始化、逻辑变量的初始化、数据的初始化。数据的初始化又可以再细分：数据的获取、数据的展示。每个细化的行为都应该封装为一个独立的方法，这样，才真正符合方法的单一性。

资源文件的单一，主要是指Android的各类资源文件，包括存放字符串的strings.xml，存放字符串数组的arrays.xml，存放颜色值的colors.xml，存放尺寸值的dimens.xml，等等。资源文件的单一，是说所有相关的资源信息要在资源文件里定义并引用到代码或布局文件里，而不是在代码或布局文件里直接定义。这样做，可以很方便地做各种适配和修改，比如支持国际化，比如不同分辨率的屏幕用不同尺寸值。iOS则没有提供和Android一样的资源文件分离的机制，但可以参考Android的做法自己去实现。

# 3. 环境分离

每个App项目，至少都会有两个环境：测试环境和生产环境。多的甚至有四个环境：开发环境、测试环境、预生产环境和生产环境。开发人员经常需要在环境之间切换，测试人员也同样。经常出现测试人员今天需要测试环境的最新版本，叫App开发人员打包一个给她，明天需要切换到生产版本，再叫App开发人员打包一个生产环境的给她。我们知道，一个App，在一台手机上要么只能是测试环境的，要么只能是生产环境的。测试人员要测试两个环境，只能不断替换不同环境的同个App，这实在太麻烦了。
为了解决此问题，最好的方案就是环境分离，不同环境有不同的App。

一个App的唯一标识，Android是用包名，iOS是用Bundle Identify。那么，在一个系统想安装不同环境的App，只要每个环境App的包名和Bundle Identify不同即可。比如，生产版的包名和Bundle Identify命名为com.mydomain.myapp，测试版的包名和Bundle Identify则命名为com.mydomain.myapp.beta，这样，Android和iOS都会识别为两个不同的App了。

不过，只改包名和Bundle Identify是不够的，应用图标和应用名称也要修改，不然安装之后很难区分哪个App是哪个环境的。一般做法就是，非生产环境的App图标就是在生产图标的基础上添加一个环境标签，同时App的应用名称也是在生产的基础上添加环境后缀名。另外，因为包名和Bundle Identify不同了，微信、微博、百度地图等这些第三方平台也都需要为不同环境的App分别申请不同的appID。

实现上，最笨的方法就是拷贝当前工程，然后修改，缺陷很明显，维护成本很高。不过，好在Android和iOS都有很方便的修改方式。

Android有了Gradle，可以设置多个不同的Flavors，每个Flavor都有一个applicationId属性，其实就是App的包名。比如，生产版和测试版的设置如下：

productFlavors {

myapp {

applicationId "com.mydomain.myapp"

}

myappBeta {

applicationId 'com.mydomain.myapp.beta'

}

}

这样，其实就有两个App了。

然后，源代码新建一个和main同级的目录，命名为myappBeta，然后，将图标、名称和第三方设置之类的，和main保持一样的位置、文件名、属性等，就可以替换成环境相关的了。iOS则可以通过创建多个环境的Target来实现环境分离，不同Target可以设置不同的Bundle Identify、Bundle display name、更换图标。

另外，每个Target也各自有自己的一份plist文件的，环境变量和第三方设置之类的，都可以设置在相应的plist文件里。



## 1. App架构设计经验谈:接口的设计

App与服务器的通信接口如何设计得好，需要考虑的地方挺多的，在此根据我的一些经验做一些总结分享，旨在抛砖引玉。

### 1.1 安全机制的设计

现在，大部分App的接口都采用1. 用户用密码登录成功后，服务器返回token给客户端；
\2. 客户端将token保存在本地，发起后续的相关请求时，将token发回给服务器；
\3. 服务器检查token的有效性，有效则返回数据，若无效，分两种情况：
RESTful架构，RESTFul最重要的一个设计原则就是，客户端与服务器的交互在请求之间是无状态的，也就是说，当涉及到用户状态时，每次请求都要带上身份验证信息。实现上，大部分都采用token的认证方式，一般流程是：

- token错误，这时需要用户重新登录，获取正确的token
- token过期，这时客户端需要再发起一次认证请求，获取新的token



然而，此种验证方式存在一个安全性问题：当登录接口被劫持时，黑客就获取到了用户密码和token，后续则可以对该用户做任何事情了。用户只有修改密码才能夺回控制权。

如何优化呢？第一种解决方案是采用HTTPS。
HTTPS在HTTP的基础上添加了SSL安全协议，自动对数据进行了压缩加密，在一定程序可以防止监听、防止劫持、防止重发，安全性可以提高很多。不过，SSL也不是绝对安全的，也存在被劫持的可能。另外，服务器对HTTPS的配置相对有点复杂，还需要到CA申请证书，而且一般还是收费的。而且，HTTPS效率也比较低。一般，只有安全要求比较高的系统才会采用HTTPS，比如银行。而大部分对安全要求没那么高的App还是采用HTTP的方式。

我们目前的做法是给每个接口都添加签名。
给客户端分配一个密钥，每次请求接口时，将密钥和所有参数组合成源串，根据签名算法生成签名值，发送请求时将签名一起发送给服务器验证。类似的实现可参考OAuth1.0的签名算法。这样，黑客不知道密钥，不知道签名算法，就算拦截到登录接口，后续请求也无法成功操作。不过，因为签名算法比较麻烦，而且容易出错，只适合对内的接口。如果你们的接口属于开放的API，则不太适合这种签名认证的方式了，建议还是使用OAuth2.0的认证机制。
我们也给每个端分配一个appKey，比如Android、iOS、微信三端，每个端分别分配一个appKey和一个密钥。没有传appKey的请求将报错，传错了appKey的请求也将报错。这样，安全性方面又加多了一层防御，同时也方便对不同端做一些不同的处理策略。
另外，现在越来越多App取消了密码登录，而采用手机号+短信验证码的登录方式，我在当前的项目中也采用了这种登录方式。这种登录方式有几种好处：

1. 不需要注册，不需要修改密码，也不需要因为忘记密码而重置密码的操作了；
2. 用户不再需要记住密码了，也不怕密码泄露的问题了；
3. 相对于密码登录其安全性明显提高了。



### 1.2 接口数据的设计

接口的数据一般都采用JSON格式进行传输，不过，需要注意的是，JSON的值只有六种数据类型：

- Number：整数或浮点数
- String：字符串
- Boolean：true 或 false
- Array：数组包含在方括号[]中
- Object：对象包含在大括号{}中
- Null：空类型

所以，传输的数据类型不能超过这六种数据类型。
我们曾经试过传输Date类型
它会转为类似于"2016年1月7日 09时17分42秒 GMT+08:00"这样的字符串，这在转换时会产生问题，不同的解析库解析方式可能不同，有的可能会转乱，有的可能直接异常了。要避免出错，必须做特殊处理，自己手动去做解析。为了根除这种问题，最好的解决方案是用毫秒数表示日期。

还出现过字符串的"true"和"false"，或者字符串的数字，甚至还出现过字符串的"null"，导致解析错误，尤其是"null"，导致App奔溃
后来查了好久才查出来是该问题导致的。这都是因为服务端对数据没处理好，导致有些数据转为了字符串。所以，在客户端，也不能完全信任服务端传回的数据都是对的，需要对所有异常情况都做相应处理。

服务器返回的数据结构，一般为：

```text
{ code：0, message: "success", data: { key1: value1, key2: value2, ... }}
```

- code: 状态码，0表示成功，非0表示各种不同的错误
- message: 描述信息，成功时为"success"，错误时则是错误信息
- data: 成功时返回的数据，类型为对象或数组

不同错误需要定义不同的状态码，属于客户端的错误和服务端的错误也要区分，比如1XX表示客户端的错误，2XX表示服务端的错误。这里举几个例子：

- 0：成功
- 100：请求错误
- 101：缺少appKey
- 102：缺少签名
- 103：缺少参数
- 200：服务器出错
- 201：服务不可用
- 202：服务器正在重启

错误信息一般有两种用途：

1. 一是客户端开发人员调试时看具体是什么错误；
2. 二是作为App错误提示直接展示给用户看。
   主要还是作为App错误提示，直接展示给用户看的。所以，大部分都是简短的提示信息。

data字段只在请求成功时才会有数据返回的。
数据类型限定为对象或数组，当请求需要的数据为单个对象时则传回对象，当请求需要的数据是列表时，则为某个对象的数组。这里需要注意的就是，不要将data传入字符串或数字，即使请求需要的数据只有一个，比如token，那返回的data应该为：

```text
// 正确
data: { token: 123456 }
// 错误
data: 123456
```

### 1.3 接口版本的设计

接口不可能一成不变，在不停迭代中，总会发生变化。接口的变化一般会有几种：

- 数据的变化，比如增加了旧版本不支持的数据类型
- 参数的变化，比如新增了参数
- 接口的废弃，不再使用该接口了

为了适应这些变化，必须得做接口版本的设计。实现上，一般有两种做法：

- 每个接口有各自的版本，一般为接口添加个version的参数。
- 整个接口系统有统一的版本，一般在URL中添加版本号，比如[http://api.domain.com/v2。](https://link.zhihu.com/?target=http%3A//api.domain.com/v2%E3%80%82)

大部分情况下会采用第一种方式，当某一个接口有变动时，在这个接口上叠加版本号，并兼容旧版本。App的新版本开发传参时则将传入新版本的version。
如果整个接口系统的根基都发生变动的话，比如微博API，从OAuth1.0升级到OAuth2.0，整个API都进行了升级。
有时候，一个接口的变动还会影响到其他接口，但做的时候不一定能发现。因此，最好还要有一套完善的测试机制保证每次接口变更都能测试到所有相关层面。

## 2. App架构设计经验谈:技术选型

当你做架构设计时，必然会面临技术选型的抉择，不同的技术方案，架构也可能完全不同。有哪些技术选型需要做决策呢？比如，App是纯原生开发，还是Web App，抑或Hybrid App？iOS开发，语言上是选择Objective-C还是Swift？架构模式用MVC，还是MVP，或者MVVM？下面根据我的一些经验对某些方面做点总结分享。

### 2.1 原生/H5

关于用原生好，还是用H5好的争论从没间断过。但我觉得，脱离了实际场景来讨论孰好孰坏意义不大。就说我们目前正在做的项目，先说明下背景：

1. 不止要做Android和iOS App，也要做微信公众号；
2. H5人员缺乏，只有一两个兼职的可用，而且不可控因素很高；
3. 我们对原生比较熟；
4. 开发时间只有半个月。

首先，需求上来说，大部分页面用H5实现，可以减少很多工作量。但因为不可控因素太高，而时间又短，风险太大。而我们对原生比较熟，开发效率比较高，很多东西我也控制得了，风险相对比较低。而且，我们的主推产品是App，微信属于辅助性产品，所以，微信要求也没那么高。因此，我决定以原生为主，H5为辅，App大部分页面用原生完成，小部分用WebView加载H5。

另外，WebView加载H5也有两种模式，一种是加载服务器的H5页面，一种是加载本地的H5页面。加载服务器的H5页面比较简单，WebView只要load一下URL就可以了。加载本地的H5页面，则需要将H5文件存放在本地，包括关联的CSS和JS文件。这种方式相对比较复杂，不过，加载速度会比第一种快很多。我们当前项目基于上面考虑，只能选择第一种方案。

如果人员和时间资源充足的话，那又如何选型呢？毫无疑问，我会以H5为主，微信和App都有的页面统一用H5，App专有的部分，比如导航栏、标题栏、登录等，才用原生实现。另外，WebView里的H5有点击事件时，也许是URL链接，也许是调用JS的，都不会让它直接在该WebView里做跳转，需要拦截下来做些原生处理后跳转到一个新的原生页面，原生页面也许嵌入另一个WebView，用来展示新的H5页面。这是简单的例子，关于Hybrid App详细的设计，以后再讲。另外，关于H5，绝对是大趋势，强烈建议所有App开发人员都去学习。

### 2.2 Objective-C/Swift

我在项目中选择了Swift，主要基于三个原因：

1. Swift真的很简洁，生产效率很高；
2. Swift取代Objective-C是必然的趋势；
3. 目前iOS只有我一个人开发，不需要顾虑到团队里没人懂Swift。

如果你的团队里没人懂Swift，那还是乖乖用Objective-C吧；如果有一两个懂Swift的，那可以混合开发，并让不懂的人尽快学会Swift；如果都懂了，不用想了，直接上Swift吧。

当语言上选择了Swift，相应的一些第三方库也面临着选型。比如，依赖库管理，Objective-C时代大部分用CocoaPods，Swift时代，我更喜欢Carthage。Carhage是用Swift写的，和CocoaPods相比，轻耦合，也更灵活。我个人也不太喜欢CocoaPods，使用起来比较麻烦，耦合性也较高，我使用过程中也经常出问题，而且还总是不知道该怎么解决，要移除时也是非常麻烦。

再推荐几个关于Swift的第三方库：

1. Alamofire：Swift版本的网络基础库，和AFNetworking是同一个作者
2. AlamofireImage：基于Alamofire的图片加载库
3. ObjectMapper：Swift版本的Json和Model转换库
4. AlamofireObjectMapper：Alamofire的扩展库，结合了ObjectMapper，自动将JSON的Response数据转换为了Swift对象

### 2.3 MVC/MVP/MVVM

先分别简单介绍下这三个架构模式吧：

- MVC：Model-View-Controller，经典模式，很容易理解，主要缺点有两个：

1. View对Model的依赖，会导致View也包含了业务逻辑；
2. Controller会变得很厚很复杂。



- MVP：Model-View-Presenter，MVC的一个演变模式，将Controller换成了Presenter，主要为了解决上述第一个缺点，将View和Model解耦，不过第二个缺点依然没有解决。
- MVVM：Model-View-ViewModel，是对MVP的一个优化模式，采用了双向绑定：View的变动，自动反映在ViewModel，反之亦然。

架构模式上，我不会推崇说哪种模式好，每种模式都各有优点，也各有极限性。越高级的模式复杂性越高，实现起来也越难。最近火热的微服务架构，比起MVC，复杂度不知增加了多少倍。

我在实际项目中思考架构时，也不会想着要用哪种模式，我只思考现阶段，以现有的人力资源和时间资源，如何才能更快更好地完成需求，适当考虑下如何为后期扩展或重构做准备。就说我前段时间分享的Android项目重构之路系列中讲的那个架构，确切地说，都不属于上面三种架构模式之一。

# 写在最后

技术选型，决策关键不在于每种技术方案的优劣如何，而在于你团队的水平、资源的多寡，要根据实际情况选择最适合你们当前阶段的架构方案。当团队拓展了，资源也充足了，肯定也是需要再重构的，到时再思考其他更合适更优秀的方案。

# 3. App架构设计经验谈:数据层的设计

一个App，从根本上来说，就是对数据的处理，包括数据从哪里来、数据如何组织、数据怎么展示，从职责上划分就是：数据管理、数据加工、数据展示。相对应的也就有了三层架构：数据层、业务层、展示层。本文就先讲讲数据层的设计。

数据层，是三层架构中的最底层，负责数据的管理。它主要的任务就是：

1. 调用网络API，获取数据；
2. 将数据缓存到本地；
3. 将数据交付给上一层。

根据这三个任务，数据层可以再拆分为三层：

- 网络层
- 本地数据层
- 交付层

## 3.1 网络层

网络层主要就是对网络API的封装。关于API的设计，该系列的第一篇文章[接口的设计](https://link.zhihu.com/?target=http%3A//www.jianshu.com/writer%23/notebooks/3855049/notes/3540213/preview)已经讲过一些。关于如何封装，可以参考Android项目重构之路系列的[架构篇](https://link.zhihu.com/?target=http%3A//keeganlee.me/post/android/20150605)和[实现篇](https://link.zhihu.com/?target=http%3A//keeganlee.me/post/android/20150629)，其中接口层和本文的网络层是一样的。

还有一些在前面的文章中没有提及到的，在此做一些补充。

首先是不同网络状态的处理。当网络不可用时，则不应该再去调用API；当网络可用，但不是WIFI时，有些比较耗流量的操作也应该禁止，比如上传和下载大文件；当网络状态不同时，还可以采用不同的网络策略，比如，当网络为WIFI时，当前API可以返回更多更全面的数据，还可以预先加载相关联的其他API。

其次，为了节省流量，接口的设计上可以对数据进行简化。例如，对于一些列表类的接口，可以这么设计：只返回更新的部分，比如，上一次请求返回了10条按时间排序的数据，第一条数据为最新的，id为101，当发起下一次请求时，将101的id作为参数调用API，API查到该id，发现该id之后又新增了两条数据，API则只返回新增的这两条数据。

另外，为了保证程序的健壮性，调用API时，对入参的合法性检查也是很有必要的。而且，也应该定义好本地的错误码和错误信息，保证每个错误都能正常解析。

## 3.2 本地数据层

本地数据层主要就是做缓存处理，这需要设计好一套缓存策略。设计缓存策略时，有几个问题需要考虑清楚：

- 哪些需要缓存？哪些不需要缓存？
- 缓存在哪里？数据库？文件？还是内存？
- 缓存时间多长？

哪些需要缓存？
将所有数据都缓存是不明智的，不同的数据应该有不同的缓存策略，比如一个电商App，首页的商品列表数据应该缓存，而且缓存时间应该比较长，而每个商品的详情数据就没必要缓存或缓存时间很短。对于一份数据需不需要缓存，判断标准可以是：用户查看该数据的频率高不高？首页商品列表是用户每次启动都会看到的，而每个商品的详情用户最多只看几次。

缓存在哪里？
从内存读取数据是最快的，但内存非常有限。因此，内存一般只用来缓存使用频率非常高的数据。
文件缓存主要就是图片、音频、视频了。
数据库可以保存大量数据，主要就是用于保存商品列表、聊天记录之类的关系型数据。
然而，不管缓存在哪里，都需要限定好缓存的容量，要定期清理，不然会越积越多。

缓存时间多长？
首先，每份缓存数据都应该设置一个缓存的有效时间，有效期的起始时间以最后一次被调用的时间为准，当该数据长时间没有再被调用到时，就应该从缓存中清理掉。

缓存的有效时间应该设多长呢？可以短至一分钟，长至一星期甚至一个月，具体因数据而异。一般内存的缓存时间不宜太长，程序退出基本就要全部清理了。文件缓存可以设置保留一天或一个星期，可以每隔一天清理一次。数据库缓存再久一些也无所谓，但最好还是不要超过一个月。

## 3.3 交付层

交付层其实就是一个向上层开放的交互接口层，是上层向数据层获取数据的入口。上层向数据层请求数据，它是不关心数据层的数据是从缓存获取还是从网络获取的，它只关心结果，数据层能给到它想要的数据结果就OK了。因此，交付层主要就是定义一堆开放的接口或协议。

如果接口或协议非常多，那么，将接口或协议按照模块划分也是有必要的。比如微信，按模块划分有：IM、公众号、朋友圈、钱包、购物、游戏等等。模块之间应该尽量相对独立、松耦合。

## 4. App架构设计经验谈:业务层的设计

业务层其实并不复杂，但是大部分开发人员对其职责并没有理解清楚，从而使其沦落为一个数据中转站。我之前分享过的[Android项目重构之路](https://link.zhihu.com/?target=http%3A//keeganlee.me/post/android/20150605)系列中提到的核心层，其实就是这里所讲的业务层。但有不少读者反映，他们在实际项目中就只是做一下参数检查，然后直接调用API，与展示层对接的接口基本也与API的接口一致的。这样，业务层无疑就已经变为了一个数据中转站。

### 4.1 业务层的职责

所以，设计业务层之前，对业务层的职责要先真正理解清楚。这里，我举两个栗子说明一下。

第一个是新用户注册的例子。
注册时，界面上一般都会要求用户输入手机号、验证码、密码和确认密码。但是，API接口一般只会有三个参数：手机号、验证码和密码，不会有确认密码。因此，调用接口之前，密码和确认密码的一致性检查是必须的。同时，也要检查这些数据是否为空、手机号是否符合规范、验证码是否有效、密码有没有包含了特殊字符等。正确姿势就是当所有检查都通过了之后，才调用API接口。最后，调用注册接口成功后，可能还要再调用一次登录接口，并可能将用户登录信息缓存起来，方便用户下次启动应用时自动登录。所有这些都属于业务逻辑处理，也就是业务层的工作。

第二个是涉及用户验证的例子。
比如，在一个电商App，当用户浏览某个商品，点击购买时，App首先会判断用户是否已经登录，如未登录，则会跳转到登录页面让用户先登录。如果已经登录，但token已经过期，那需要先去获取新的token，之后才能进行下一步的购物操作。这些逻辑处理，也是业务层的工作。

因此，业务层就是处理业务逻辑，包括数据的检查、业务分支的处理等。
比如上面第二个例子，可能很多人就会将用户是否已经登录的判断直接在界面上做处理，当确认登录后，token也是有效的之后，才调用业务层做购买商品的操作，这就是导致业务层沦落为API的数据中转站的直接表现。

### 4.2 业务层的交互

只有真正理解了业务层的职责之后，才能有效地设计业务层与外层的交互接口。

业务层向下，与数据层交互；向上，与展示层交互。

与数据层交互只是调用数据层的接口获取数据，而与展示层交互则需要提供接口给展示层调用。因为业务处理一般属于比较耗时的操作，主要在于底层的网络请求比较耗时，所以提供给展示层的接口数据结果应该以异步的方式提供，因此，接口上就需要提供个回调参数，返回业务处理之后的结果。我之前分享过的[Android项目重构之路:实现篇](https://link.zhihu.com/?target=http%3A//keeganlee.me/post/android/20150629)有讲到一种实现方式，可参考。

## 5. App架构设计经验谈:展示层的设计

展示层是三层架构中最复杂的一层了，需要考虑的包括但不限于界面布局、屏幕适配、文字大小、颜色、图片资源、提示信息、动画等等。展示层也是变化最频繁的一个层面，每天改得最多的就是界面了。因此，展示层也是最容易变得混乱不堪的一个层面。一个良好的展示层，应该有较好的可读性、健壮性、维护性、扩展性。

### 5.1 三原则

我在[Android项目重构之路:界面篇](https://link.zhihu.com/?target=http%3A//keeganlee.me/post/android/20150619)中提到过三个原则，要设计好展示层，至少需要遵循好这三条基本的原则：

1. **保持规范性**：定义好开发规范，包括书写规范、命名规范、注释规范等，并按照规范严格执行；
2. **保持单一性**：布局就只做布局，内容就只做内容，各自分离好，每个方法、每个类，也只做一件事情；
3. **保持简洁性**：保持代码和结构的简洁，每个方法，每个类，每个包，每个文件，都不要塞太多代码或资源，感觉多了就应该拆分。

关于这三个原则详细的解说，界面篇已经讲过的，我这里就不再重复。在此，我只做些补充。

关于规范，Android方面，我已经分享过一套[Android技术积累:开发规范](https://link.zhihu.com/?target=http%3A//keeganlee.me/post/android/20150709)，主要分为书写规范、命名规范、注释规范三部分。iOS方面，苹果已经有一套[Coding Guidelines](https://link.zhihu.com/?target=https%3A//developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html)，主要属于命名方面的规范。当我们制定自己的开发规范时，首先就要遵守苹果的这份规范，在此基础上再加上自己的规范。

最重要的不是开发规范的制定，而是开发规范的执行。如果没有按照开发规范去执行，那开发规范就等于形同虚设，那代码混乱的问题依然得不到解决。

另外，Android系统本身已经对资源进行了很好的分离，字符串、颜色值、尺寸大小、图片、动画等等都用不同的xml文件定义。而iOS系统在这方面就逊色很多，只能自己实现，其中一种实现方案就是通过plist文件的方式实现和Android一样的机制。

### 5.2 工程结构

工程结构其实就是模块的划分，无非分为两类：按业务划分或按组件划分。
比如一个电商App，可能会有首页、附近、分类、我的四大模块，工程结构也根据这四大模块进行划分，Android可能就分为了四个模块包：

- com.domain.home 首页
- com.domain.nearby 附近
- com.domain.category 分类
- com.domain.user 我的

同样的，iOS则分为四个分组：home、nearby、category、user。

之后，每个模块下相应的页面就放入相应的模块。那么，问题来了，商品详情页应该属于哪个模块呢？首页会跳转到商品详情页，附近也会跳转到商品详情页，分类也会跳转到商品详情页，用户查看订单时也能跳转到商品详情页。有些页面，并不能很明显的区分出属于哪个模块的。我接手过的，按业务划分的二手项目中（即不是由我搭建的项目），我要找一个页面时，我认为应该属于A模块的，但在A模块却找不到，问了同事才知道在B模块。类似的情况出现过很多次，而且不止出现在我身上，对业务不熟悉的开发人员都会出现这个问题。而且，对业务不熟悉的开发人员开发新的页面或功能时，如果对业务理解不深，划分出错，那也将成为问题，其他人员要找该页面时更难找到了。
因此，我更喜欢按组件划分的工程结构，因为组件每个人都懂，不管对业务熟不熟悉，查找起来都明显方便很多。Android按组件划分大致如下：

- com.domain.activities 存放所有的Activity
- com.domain.fragments 存放所有的Fragment
- com.domain.adapters 存放所有的Adapter
- com.domain.services 存放所有的Service
- com.domain.views 存放所有的自定义View
- com.domain.utils 存放所有的工具类

iOS的分组则大致如下：

- controllers 存放所有ViewController
- cells 存放所有Cell，包括TableViewCell和CollectionViewCell
- views 存放所有自定义控件或对系统控件的扩展
- utils 存放所有的工具类

### 5.3 基类的定义

Android的Activity、Fragment、Adapter，iOS的ViewController，分别定义一个基类，将大部分通用的变量和方法定义和封装好，将减少很多工作量，而且有了统一的设置，也会减少代码的混乱。比如我在[Android项目重构之路:实现篇](https://link.zhihu.com/?target=http%3A//keeganlee.me/post/android/20150629)中提到的KBaseActivity和KBaseAdapter的实现就是例子，当然还可以抽离出更多变量和方法。
每个Activity的onCreate()方法，一般分为三步：

1. 变量的初始化；
2. View的初始化；
3. 加载数据。

因此，其实可以将onCreate()方法拆分成三个方法：

1. initVariables()
2. initViews()
3. loadData()

在基类中将这三个方法定义为抽象方法，由子类去实现，这样，子类就不需要实现onCreate()方法了，只要实现更细化的上述三个方法即可。

iOS的ViewController也是同样的方式，这里就不重复了。

### 5.4 写在最后

自此，该系列的文章暂时就完结了，方法论比较多，很少涉及到具体的实现。因为具体实现的方案很多，而且还要结合实际项目，无法说哪个方案好哪个方案差。但方法论大部分是想通的，所以，本系列主要讲方法论。



# 参考

https://zhuanlan.zhihu.com/p/57101445

https://zhuanlan.zhihu.com/p/57644102